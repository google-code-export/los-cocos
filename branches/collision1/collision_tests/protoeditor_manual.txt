protoeditor manual
==================

overview
--------

I wanted to write a mini-game with some levels to demonstrate use cases for the new collision module, and disliked the idea of random level generators or text descriptions with custom parser.
Having coded mouse selection as part of collision development, I was tempted to coble up a very basic editor, and that is protoeditor.

Be warned that it is an intermediate sketch toward a real spec and real editor.

The goodies:
	quickly define which actors are available and how they should look in editor
	editor not forces any particular implementation of ingame actors
	can edit even when game code has not been written (or it is broken)
	zoom, scroll, select by mouse pick or elastic box, drag selection, duplicate selection, delete selection (interactions in the Inkscape way) 
	supports versioning: growing a game implies successive upgrades to your classes, which sometimes requires to upgrade stored levels. protoeditor can help with that, see the section 'upgrading the ingame classes'
	
The shortcomings are:
    No undo (save frequently)
    Save silently overwrites target (commit frequently, use interpreter layer
    to change target filename)
    No copy & paste ('duplicate' partially replaces those)
    No gui editor for actor properties (use interpreter layer)
    No validation.

Should you use this tool ?
If you want to make something simple, in a short time span, can't wait for more complete versions, and you like the description, then maybe yes.
If you expect to use at pyweek 13 ( 2011 September 11 ), I strongly suggest to make a mini-game before, both to know if it feels good for you, and to familiarize with the persistence format.

Setting up protoeditor to work with a new game
----------------------------------------------

The section's goal is to learn 

	+ how to setup all neccesary things to start editing maps for your game idea.
	  You don't need to have any code for the game to start.

1. do initial directory layout. I choose

gamedir
	data
		editor : images used by editor to show actors
		levels : game levels
		
The *.py in your game will go under gamedir
Copy there start_editor.py, you can get it from the runner example

2. put some placeholder images for your actors in gamedir/data/editor
		
3. Decide if you want to include the editor into gamedir or not. Incorporation allows to adjust one time the paths in start_editor.py and then anyone who does a checkout is done with the path; also if you need to hack the editor you can commit along the game.

Adapt start_editor.py to your use case; you will need some adjustments, basically paths. The script is short and commented.

If you bundle the editor into the working copy, the protoeditor path should be relative to the start_editor.py working dir. This way, you need no adjusts after doing a check out.
If not bundling the editor, adjustments to protoeditor_path may be necessary when checking out to different boxes.

The other paths needed should be relative to the start_editor.py working dir.

Also, depending on your OS, or if you want to use a specific python between many in your system, you may need to adjust in start_editor.py how the string for os.system call is built.

4.  Now you should tell the editor a few specific things about the game; this is done by filling a 'game' dict in your gamedef.py module.
The exact values are not critical, you can tweak later whatever needs adjust. 
You can start with a copy of gamedef_sample_00_01.py, found in the protoeditor directory. The sample looks like:

game = {
    "unversioned_name": "Alien Cowboy Zombies",
    "max_width": 1200.0,
    "max_height": 1000.0,
    "editor_picker_cell_width": 32.0 * 1.25,
    "roles" : {
        "level": {
            ('levelproxy 00.01', 'level 00.01'): {
                'width': 1200.0,
                'height': 1000.0,
                'others': {
                    }
                }
            },
        "actor": {
            ('actorproxy 00.01', 'player 00.01'): {
                'editor_img': 'goodguy.png',
                'visible_width':  32.0,
                'others': {
                    },
                }
            ,
            ('actorproxy 00.01', 'enemy 00.01'): {
                'editor_img': 'badguy.png',
                'visible_width':  32.0,
                'others': {
                    },
                }
            ,
            # other actors
        }
    }
}

To customize this sample you adjust

"unversioned_name" : a string with your game name, say it is "Crazy Alien"

"max_width", "max_height" : Maximum width and size for your world, in world coordinates, say it is 1300.0 and 900.0
	
ingame_type_id : String identifiers for each of the actor variants, and for the only one level variant. For convenience it should bring to mind which role plays in the game and what version it its.
The ingame_type_id goes as the second member in the tuples under each variant of "role" 
Say you choose the identifiers
	'level 00.01' # for levels
	'player 00.01' # actor, player
	'purple monster 00.01' # actor, a type of enemy
	'flaming devil 00.01' # actor, a type of enemy
		
"width" and "height" for the 'level 00.01' variant, they are the default values editor will use when instantiating like 'new', as opposed to 'load'; say you chose 1100.0 and 800.0 
		
"editor_img" for each variant of actor. This is the name of image files that represent actors in the editor, the ones that you provide in 2.
Paths are relative to the 'path to resources that game provides to editor' that you adjusted for start_editor.py in 3; supposing you set it as 'gamedir/data/editor', then example names can be
	'player9.png'
	'purplemonster.png'
	'devil.png'
	
"visible_width" for each actor variant.	The default actor width in world units. Notice there is not a visible_height because the editor will scale maintaining the aspect ratio. Say you chose 32.0, 40.0, 64.0 for player, purple and devil 

"editor_picker_cell_width" .
	Here you do a rough guess, which can be
		k ~ max {actor.visible_width * 1.25 : all actors}
    This can be too big if there are few instances with big visible_width, then you can exclude those before taking max.
    Don't spend time here except if the editor mouse selection seems too laggy.
	In the example case that would be 
	something like 1.25 * max {32.0, 40.0, 64.0} = 80.0 
	
All right, the final gamedef.py should look like:

game = {
    "unversioned_name": "Crazy Alien",
    "max_width": 1300.0,
    "max_height": 900.0,
    "editor_picker_cell_width": 80.0,
    "roles" : {
        "level": {
            ('levelproxy 00.01', 'level 00.01'): {
                'width': 1100.0,
                'height': 800.0,
                'others': {
                    }
                }
            },
        "actor": {
            ('actorproxy 00.01', 'player 00.01'): {
                'editor_img': 'player9.png',
                'visible_width':  32.0,
                'others': {
                    },
                }
            ,
            ('actorproxy 00.01', 'purple monster 00.01'): {
                'editor_img': 'purplemonster.png',
                'visible_width':  40.0,
                'others': {
                    },
                }
            ,
            ('actorproxy 00.01', 'flaming devil 00.01'): {
                'editor_img': 'devil.png',
                'visible_width':  64.0,
                'others': {
                    },
                }
            ,
            # other actors
        }
    }
}

5. You are ready to edit levels now.

Editing a map
-------------

The section's goal is to learn 
	+ how to create or load a map
	+ how to save a modified map
	+ how to modify a map

Starting to code the game
-------------------------		

The section's goal is to learn

 + how to load a level
 + how to customize the level and actor classes
 + how to manage code upgrades that mandates upgrades in stored data

Loading
 
The directory level_loader_demo has all the code you need to begin with.
You can run the demo to see that it loads a level, albeit not the one you edited before. To straighten that,

1. In your own gamedir copy the directory 'data/editor' to 'data/images'. This will made placeholder images for your actors available for the gamecode, and the resource names or paths will point to ingame resources

2. From the directory level_loader_demo copy the files
actors.py
level.py
loader.py
loader_demo.py
persistence.py

to your gamedir directory; do not copy other files or you can be in trouble.

3. The demo uses ingame_type_id s and class names for actors and level that surely will not match the ones you want. So, in your gamedir:
	i. edit level.py to change the class name associated to ingame level if you want; you should then update the name in loader.py , function ingame_cls_from_combo_type
	
	ii. In actors.py change the class names for actors to the ones you want, adding or deleting classes if necessary. Update loader.py, function ingame_cls_from_combo_type with the new names, adding or deleting if necessary.

4. If you named your level other than 'level_00.lvl' adjust the name in loader_demo.py

5. Run in your gamedir loader_demo.py . It should show the level you have designed,
without the default background, and at a scale different than the one seen in editor. Look at the docstring if you want to adjust the scale.

6. Rename loader_demo.py to start_game.py 
This is the initial version of your game.
It only loads a level and show it on screen, so you will want to add code that make things happen.
There are a few things that you must know to maintain compatibility between your ingame code, protoeditor code and the stored levels along the changes you will be doing.
Look at the following sections for that.

Customizing the level and actor classes

First of all, classes for game entities that will not be stored in files saved by the editor don't need to follow any special rule. Examples are bullets or auras for actors. And of course they can be added to the level instance while ingame.
In what follows, then, the world 'actor' would refer only to entities that needs to be stored in a map file.

The classes for entities stored in maps are special and need to follow certain rules while upgrading.
The rules are meant to allow upgrade your code while at the same time
	ensure editor can save the state required by your updated code
	ensure loader.py can handle the new stored format
	ensure you can upgrade your stored levels to the new format
	ensure you can mix in the call to __init__ the stored parameters with others produced on the fly 
	
Renaming classes and/or changing the module where a class lives (level or actor)

Rename class names at will, but update the names in loader.py, function ingame_cls_from_combo_type
If you move a class to another module, you should update the module name in loader.py, function ingame_cls_from_combo_type
	
Changing base classes for actors	

You are not forced to use the same base class for all actors, and you are not forced to use cocos.sprite.Sprite as base class for actor.

To produce an alternative BaseActor to use as base of some of your actors you can:

    Make a copy of the original BaseActor

    Rename BaseActor to whatever you want
	
	Change the parent class for the actors you want to use the new actors base class.
	
	You are done with the separation. Stored levels dont need upgrade.
	Obviusly you then want to change the code in the new base class, but read ahead before you do.

To change the BaseActor base class from Sprite to something else you need to:

	Change cocos.sprite.Sprite in the BaseActor declaration to the base class you want.

    Adjust the __init__ code and signature if necessary, but to do so read the other sections about changes in code and in __init__ parameters 

	The only extra changes you need to do will be mandated by the previus step.
	
Changing code when you don't need to receive extra info in the __init__:

	Straightforwad, change the code and you are done. But dont touch sections marked 'dont edit'.
	
Changing code when you need to receive extra info in the __init__, and this info will not be stored in the saved level:
A common case for this is passing the level instance to actor, so that actor can use services like navigation, collision, spawn bullets.
Another example is wanting to pass some value generated on the fly, at the instantiation moment.

For most cases you can use an easier approach: pass the standard info to the __init__, and follow inmediatelly with a .set_extra_info(<your info>): this way you are in the easiest case of code change, see above.

If really really you need to have that info available at init time then you do: 

	The new info must be passed as a positional argument, not a keyword argument
	
	The proper order for positional arguments is
		self,
		<positional arguments for level (resp BaseActor) as seen in the demo>
		<custom positional arguments for level (resp the ones that all subclasses of a BaseActor share)>
		<custom positional arguments for actors not shared for all subclasses of a BaseActor>
	
	Insert your new argument, respecting the above mentioned order
	
	Now you must update code calling the changed __init__ : when your code calls directly __init__ you know how to do it, but the calls comming indirectly from the loader are a bit different.
	Those calls are in forbiden territory, and are made by methods with the signature
	    def new_from_dict(cls, game, args, description_dict):
	Here 'args' carry the values for all your custom positional parameters, that is, the last two categories in the above 'proper order list'.

	For level class the one call to this method lives in loader.py, function load_level; locate the call to new_from_dict; above it is the preparation of args params for the call. Edit as necesary to add the value required by the new positional argument.
	
	For actor classes the thing is similar, but along the time it can complicate:
	At first, theres only one point in code where new_from_dict is called for actors, and it is in level.py, method fill.
	In that situation, if you are adding the same parameter to all your classes, you work as in level: modifing the code above the call to add the extra value needed.
	But if you are adding a parameter only to some clases, then you need to add some logic to prepare different args for diferent classes.

	Allright, after you fixed the code to pass the correct args to new_from_dict you are done.

Changing code when you need to receive extra info in the __init__, and this info will be stored in the saved level

By example, you want to specify which music theme will sound in each level, and want that info stored in saved map.

	__init__ py receives a dictionary in the keyword param 'others'; your info will come there as a keyword value pair
	Notice that value is allowed to be : All scalars (None, int, bool, float, etc), tuples, list, dict and any nesting of them.  
	Choose which key you want to use for your info, by example 'music'.
	
	The __init__ signature does not change
	
	Add code in __init__ to extract your info (ex: music = others['music']) and then use it.
	
	Bump the version in the ingame_type_id for your class, in your class definition
	
	Edit gamedef.py in the section that maps your class:
		Update the ingame_type_id.
		In the sub-section 'others', add the new key and the default value that will be used by editor when doing a 'new object'
		By example
		others: {
			'music': 'Twist and Shout'
			}
			
	Edit loader.py, function combo_type_to_cls: update the ingame_type_id for your class  

	Bump version numbers, notice that if you are adding to a BaseActor then you must bump versions for all subclasses
	
	Adjust for the bumped version numbers in loader.py, function ingame_cls_from_combo_type
	
	Upgrade conversions.py so it can handle dictionary conversion between versions, see below

	


	
	
