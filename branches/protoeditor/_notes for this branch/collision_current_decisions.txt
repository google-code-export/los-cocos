

Broad decisions about the API

	define a general API that not depends on any underlaying algorithm
	
	at least to explore the solution space the code stack should be flexible to accommodate variants and different base algorithms. but don't do too much indirection

	define how to select and initialize a concrete implementation, including pass of algorithm's tweak parameters

	when user code switches to another algorithm, the only code that needs updating is the line selecting and initializing the concrete implementation

	A reference implementation using brute force method will be written first, allowing to concentrate in the API design, and later retained for testing purposes

	Have a (loosely speaking) abstract base class CollisionManager, its responsibility is define with certain detail the interface answering collision questions. It should not enter in implementation details, and the answers are:

		most important:
			actor1 and actor2 overlap ?
			which actors collide with actor1 ?
			which actors are near actor1 ?
			
		bonus points:
			for mouse hit detection: which actor(s) overlaps point (x,y) ?
			for instant bullet collision and navigation: get first actor (if any) that collides with a ray of origin (x0, y0) and direction (d0, d0) 
			if actor1 collides with actor2, at user request estimate:
				contact point
				contact normal
				how much overlap
	
	Work will start focusing at most important questions, when that is fleshed out, upgrade to bonus points will follow.

	Have one concrete manager per algorithm to try, by example
		CollisionManagerBruteForce
		CollisionManagerCellGrid
		CollisionManagerQuadtree
	These managers implements the interface defined by CollisionManager
	
	Try to not subclass the above mentioned managers to express variants
	

The first implementation will have the restrictions:
	No sub-actor collision support

	No level of detail collision

	For collision purposes each collidable actor will be associated with a simple geometrical shape

	All the collidables known by a concrete instance of CollisionManager will share the same qualitative shape (all discs, or all rectangles, or ...)

	(actor1 collides with actor2) would be equivalent to (shape1 overlaps shape2)

	Supported Shapes: CircleShape, AARectShape (axis aligned rectangle)

	
A reference implementation using brute force will be written first, and be retained for unit testing purposes

Support for Model - View separation is desired, but also a version targeted at 'actors as augmented CocosNodes'
To accomplish both goals, I tentatively will go with: 

	have a module collision_model supporting decoupling model - view
		collidables are not supposed to be of a particular class
		the api that collidables objects offer to the collision model is unassuming and well defined
		using the module should not require window instantiation
		
	have a node_collision module supporting the second style, where core functionality is delegated to collision_model.
		collidable is known to be a CocosNode, and that it is included in the world by being added to the scene tree.

Work will focus on collision_model until is usable, then node_collision should be reevaluated.

