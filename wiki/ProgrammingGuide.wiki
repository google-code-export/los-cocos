#summary Programming Guide
#labels Phase-Implementation

= Introduction =

"cocos" is a framework for building games, demos, and other graphical/interactive applications. It is built over [http://www.pyglet.org/ pyglet]. It provides some conventions and classes to help you structure a "scene based application".

A cocos application consists of several scenes, and a workflow connecting the different scenes. It provides you a "director" (a singleton) which handles that workflow between scenes. Each scene is composed of an arbitrary number of layers; layers take care about draw to the screen (using the pyglet and opengl APIs), handle events and in general contain all of the game/application logic.

Los Cocos make easier for you, developer, to define a workflow for your game, compose scenes and scene components, reuse your code, and have a nice graphical presentation without too much work.

== Basic concepts ==

There are some basic concepts introduced in this library that you will need to know when developing a cocos application:

=== Scenes & Transitions ===

An scene is a more or less an independent piece of the app workflow. Some people may call them "screens" or "stages". Your app can have many scenes, but only one of them is active at a given time.

For example, you could have a game with the following scenes: Intro, Menu, Level 1, Cutscene 1, Level 2, Winning cutscene, losing cutscene, High scores screen. You can define every of one of these scenes more or less as separate apps; there is a bit of glue between them containing the logic for connecting scenes (the intro goes to the menu when interrupted or finishing, Level 1 can lead you to the cutscene 1 if finished or to the losing cutscene if you lose, etc.).

A cocos Scene is composed of one or more layers, all of them piled up. Layers give the scene an appearance and behavior; the normal use case is to just make instances of Scene() with the layers that you want. 

There is also a family of Scene classes called "Transitions", which allow you to
make transitions between two scenes (fade out/in, slide from a side, etc).

=== Director ===

The director is the component which takes care about going back and forth between scenes.

The director is a shared (singleton) object. It knows which scene is currently active, and it handles a stack of scenes to allow things like "scene calls" (pausing a scene and putting it on hold while other enters, and then returning to the original). Is the one who will actually change the scene, after a layer has asked for push, replacement or end of the current scene.

=== Layers & Effects ===

A layer has as size the whole drawable area (window or screen), and knows how to draw itself. It can be semi transparent (having holes and/or partial transparency in some/all places), allowing to see other layers behind it. Layers are the ones defining appearance and behavior, so most of your programming time will be spent coding Layer subclasses that do what you need. The layer is where you define event handlers. Events are propagated to layers (from front to back) until some layer catchs the event and accepts it.

Even if any serious app will require you to define some layer classes, cocos provides a library of useful predefined layer (a simple menu, solid color, a multiplexor between other layers, and a layer to add animated sprites/particle effects)

Besides that, you can apply an "effect" to a layer; effects transform the appearance of the whole layer. There are some classes to allow you to more or less easily define new effects. Cocos bring a couple of ready-to-use effects (colorization i.e. changing color or transparency of a layer, and repositioning i.e. moving or resizing a layers). Effects can be dynamically enabled/disabled/reconfigured; this allow to redefine the given effects to create effects as "flickering" or "shaking", and apply these effects to your layers.

=== Actions & Sprites ===

A Cocos' sprite is like any other computer sprite. It is a 2D image that can be moved, rotated, scaled, etc.

These sprites supports actions. An Action is "something" that the sprite can do, and an sprite can do multiple actions at the same time. Also, 2 or more different sprites can run the same action at the same time. There are different kind of actions. There are 3 actions categories:
  * Actions that lets you transform the sprite's properties (position, rotation, transparency...)
  * Actions that combines other actions
  * Actions that do something else

== Requirements ==

 * Python 2.4 or later
 * Pyglet 1.0 or 1.1

== Install ==
{{{
cp -r cocos $PROJECT_HOME
}}}

or

{{{
export PYTHONPATH=$PYTHONPATH:/path/to/cocos
}}}

or 
{{{
import sys
sys.path.insert(0, PATH_TO_COCOS))
}}}

== Contact us ==

Website: http://code.google.com/p/los-cocos/

If you find any bug, please report it at: http://code.google.com/p/los-cocos/issues/list


= Details =

== A First Program ==

The most basic program (which does something) you can make, does the following:

 # Define a layer which shows something (For example, a "Hello world" string). To define a new layer class you inherit `cocos.layer.Layer`. In the `step' method you should define the code that paints the layer on screen (using pyglet or opengl functions):
{{{
class HelloWorld(cocos.layer.Layer):
    def __init__(self):
        # see pyglet documentation for help on this lines
        ft = font.load('Arial', 36)
        self.text = font.Text(ft, 'Hello, World!', x=100, y=240)
        
    def step(self, dt):
        # this funcition is called on every frame
        # dt is the elapsed time betwen this frame and the last
        self.text.draw()
}}}
 # Start the director. This initializes the window/display, and sets up cocos
{{{
    # director init takes the same arguments as pyglet.window
    director.init()
}}}
 # Create an instance of the layer defined above...
{{{
    # We create a new layer, an instance of HelloWorld
    hello_layer = HelloWorld ()
}}}
 # ...and a scene, with just that layer inside:
{{{
    # A scene that contains the layer hello_layer
    main_scene = cocos.scene.Scene (hello_layer)
}}}
 # Finally, tell the director to run with that scene
{{{
    # And now, start the application, starting with main_scene
    director.run (main_scene)
}}}

Of course, the last three steps sometimes can be shortened to just `director.run( cocos.scene.Scene( HelloWorld() ) )`; our hello world app is a bit verbose to make clear which are the steps involved.


This example is complete at `samples/hello_world.py`, and you can run it and play with it:

=== hello_world.py ===
{{{
import cocos
from cocos.director import director

from pyglet import font

class HelloWorld(cocos.layer.Layer):
    def __init__(self):
        # see pyglet documentation for help on this lines
        ft = font.load('Arial', 36)
        self.text = font.Text(ft, 'Hello, World!', x=100, y=240)
        
    def step(self, dt):
        # this funcition is called on every frame
        # dt is the elapsed time betwen this frame and the last        
        self.text.draw()

if __name__ == "__main__":
    # director init takes the same arguments as pyglet.window
    director.init()
    # We create a new layer, an instance of HelloWorld
    hello_layer = HelloWorld ()
    # A scene that contains the layer hello_layer
    main_scene = cocos.scene.Scene (hello_layer)
    # And now, start the application, starting with main_scene
    director.run (main_scene)
    # or you could have written, without so many comments:
    #      director.run( cocos.scene.Scene( HelloWorld() ) )
}}}


== Director, Scene, Layer ==
=== Multiple Layers ===
{{{
import cocos
from cocos.director import director

from pyglet import gl

# we ccreate our own layer
class Square(cocos.layer.Layer):
    def __init__(self, color, x, y, size=50):
        self.x = x
        self.y = y
        self.size = size
        self.color = color
                
    def step(self, dt):
        # this layer just draws a square in self.color with self.size as it side
        gl.glColor4f(*self.color)
        x, y = self.x, self.y
        w = x+self.size; h=y+self.size
        gl.glBegin(gl.GL_QUADS)
        gl.glVertex2f( x, y )
        gl.glVertex2f( x, h )
        gl.glVertex2f( w, h )
        gl.glVertex2f( w, y )
        gl.glEnd()
        gl.glColor4f(1,1,1,1) 
        
if __name__ == "__main__":
    # create the window
    director.init()

    # create our scene with some layers. Layers in scene creation are automatically
    # assigned a z-value from 0 to len(layers)-1
    # this means the first layers will be in the bottom, the last one on top.
    sc = cocos.scene.Scene( 
        *[ Square((0.03*i,0.03*i,0.03*i,1) , i*20, i*20) for i in range(5,20) ]
        )

    # we can add more layers after the scene has been created
    # we specify z-value and a name, used as reference if we want to remove it later
    sc.add( 5.5, Square((1,0,0,0.5), 150,150, 210 ), "big_one" )

    # run it
    director.run( sc )
}}}
=== Events ===
All layers are event handlers from the pyglet event framework. When a layer is being shown, it event handlers will be active.

See:
 -  http://www.pyglet.org/doc/programming_guide/the_pyglet_event_framework.html
 
=== Scenes Stack ===

Note that you can add a single layer object to multiple
scenes, allowing sharing (this can be useful if you want to reuse a layer, specially if
you need it to keep state between scenes).

== Sprites ==

=== Actions ===

==== Transformation actions ====
The _duration_ parameter is specified in seconds. The x,y parameters are specified in pixels. The (0,0) point is the bottom-left point.
 * *Move*( (delta_x,delta_y,0), duration)
   * Moves the sprite delta_x and delta_y pixels in duration time. 
 * *Goto*( (x,y,0), duration )
   * Moves the sprite to the x,y coordinates.
   * The difference between _Move()_ and _Goto()_ is that _Move()_ is relative to the current coordinates and _Goto()_ is absolute.
 * *Rotate*( degrees, duration )
   * Rotates the sprites degrees in duration time. Positives degrees rotates the sprite counter-clockwise.
   * The rotation is relative to the current angle.
 * *Scale*( zoom_factor, duration )
   * Scales the sprites zoom_factor in duration time.
   * The scale is relative to the current zoom_factor.
 * *Jump*( height, x, number_of_jumps, duration )
   * Moves the sprites x pixels in duration time. x is relative to the current x position.
   * During that movement the sprite will do a number_of_jumps of height.
 * *Bezier*( bezier_configuration, duration )
   * Moves the sprite using a bezier path in duration time. The movement is relative to the current position.
 * *Place*( (x,y,0) )
   * Places the sprite in the x,y coordinates.
 * *Animate*( animation_name )
   * Animates the sprite using an animation name.
   * Before running an animation, you need to create an _Animation_, and you must add it to the sprite.
 * *!FadeIn*( duration )
   * Fades the sprite in in duration time.
 * *!FadeOut*( duration )
   * Fades the sprite out in duration time.
 * *Blink*( times_to_blink, duration )
   * Blinks the sprite times_to_blink in duration time.
 * *Show*()
   * Shows the sprite.
 * *Hide*()
   * Hides de sprite. To show it again, use the Show action.

==== Composite actions ====
 * *Repeat*( action, times, mode=PingPongMode )
   * Repeats an action.
   * If _times_ is -1, then it will repeat the action forever. Default is -1
   * If mode is PingPongMode (default mode) it will repeat the action forwards and backwards.
   * If mode is !RepeatMode, then it will always repeat the actions forwards.
 * *Sequence*( list_of_actions, dir=!ForwardDir ) _or_ action1 + action2 + action3...
   * Runs a list of actions is sequential mode. First it runs the first action. When this action finished, it execute the next one until the last one is executed.
 * *Spawn*( list_of_actions ) _or_ action1 | action2 | action3...
   * Execute the list_of_actions at the same time

==== Misc Actions ====
 * *!CallFunc*( function )
   * Calls a function. Just that.
   * It is useful to when you want to trigger something.
 * *CallFuncS*( function )
   * It is the same is _!CallFunc_ with the difference that _function_ will receive the sprite as the 1st argument
 * *Delay*( seconds )
   * It will delay the execution some _seconds_
 * *!RandomDelay*( lo_seconds, hi_seconds )
   * It will delay the execution random seconds between _lo_seconds_ and _hi_seconds_

You can find an excellent example in: _los-cocos/test/test_sprite.py_

=== Implementing Actions ===

== Transitions ==
=== Implementing New Transitions ===

== Effects ==
Effects can be shared between layers

=== Implementing New Effects ===

= Packaged Layers =
== Basic Layers ==
`ColorLayer( *color )` creates a layer filled with color (RGBA)
`MultiplexLayer( *layers )` A Composite layer that only enables one layer at the time

== Menus ==